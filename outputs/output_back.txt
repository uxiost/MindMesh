The following text is a Git repository with code. The structure of the text are sections that begin with ----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the Git repository ends when the symbols --END-- are encounted. Any further text beyond --END-- are meant to be interpreted as instructions using the aforementioned Git repository as context.
----
app.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
# from starlette.middleware.cors import CORSMiddleware
from routers import users, llm_identities, threads, messages, auth

from dotenv import load_dotenv
import os

load_dotenv()

app = FastAPI()

# Set up CORS middleware
origins = [
    "http://localhost:3000",  # Adjust this to your frontend's development server URL
    "http://localhost",
    os.environ.get('FRONTEND_URL'),  # Replace this with your production frontend URL
    os.environ.get('REACT_APP_BACKEND_URL')
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(users.router)
app.include_router(llm_identities.router)
app.include_router(threads.router)
app.include_router(messages.router)
app.include_router(auth.router)
----
database.py
import os
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

from dotenv import load_dotenv
load_dotenv()

DATABASE_URL = os.environ.get("DATABASE_URL")

engine = create_engine(DATABASE_URL, echo=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

----
dependencies.py
from fastapi import Depends, HTTPException
from google.oauth2 import id_token
from google.auth.transport import requests
from sqlalchemy.orm import Session
from pydantic import BaseModel
from models import User
from database import get_db
import os

from dotenv import load_dotenv
load_dotenv()


class Token(BaseModel):
    token: str

def get_authenticated_user(token: Token, db: Session = Depends(get_db)):
    CLIENT_ID = os.environ.get('REACT_APP_GOOGLE_CLIENT_ID')
    try:
        idinfo = id_token.verify_oauth2_token(token.token, requests.Request(), CLIENT_ID)

        if idinfo['aud'] != CLIENT_ID:
            raise ValueError('Could not verify audience.')

        user_id = idinfo['sub']

        # Check if the user exists in the database
        existing_user = db.query(User).filter(User.google_account_id == user_id).first()

        if not existing_user:
            raise HTTPException(status_code=404, detail="User not found")

        return existing_user

    except ValueError as e:
        print(e)
        raise HTTPException(status_code=401, detail="Invalid token")
----
init_db.py
from database import engine
from models import Base

if __name__ == "__main__":
    Base.metadata.create_all(bind=engine)
    print("Tables created.")
----
models.py
from sqlalchemy import Column, Integer, String, ForeignKey, DateTime, Boolean, Table
from sqlalchemy.orm import relationship
from database import Base
from datetime import datetime

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    google_account_id = Column(String, unique=True, index=True)
    email = Column(String, unique=True, index=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    llm_identities = relationship("LLMIdentity", back_populates="user")

class LLMIdentity(Base):
    __tablename__ = "llm_identities"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    model_name = Column(String, index=True)
    model_id = Column(String, unique=True, index=True)
    api_token = Column(String)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    user = relationship("User", back_populates="llm_identities")
    threads = relationship("Thread", secondary="llm_identity_thread")

class Thread(Base):
    __tablename__ = "threads"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, index=True)
    is_public = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    messages = relationship("Message", back_populates="thread")
    llm_identities = relationship("LLMIdentity", secondary="llm_identity_thread")

class Message(Base):
    __tablename__ = "messages"

    id = Column(Integer, primary_key=True, index=True)
    thread_id = Column(Integer, ForeignKey("threads.id"))
    llm_identity_id = Column(Integer, ForeignKey("llm_identities.id"))
    content = Column(String)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    thread = relationship("Thread", back_populates="messages")
    llm_identity = relationship("LLMIdentity")

# Association table for LLMIdentity and Thread
llm_identity_thread = Table(
    "llm_identity_thread",
    Base.metadata,
    Column("llm_identity_id", Integer, ForeignKey("llm_identities.id"), primary_key=True),
    Column("thread_id", Integer, ForeignKey("threads.id"), primary_key=True)
)
----
tests/test_users.py
from fastapi.testclient import TestClient
from app import app
from models import User
from database import SessionLocal

client = TestClient(app)

def test_create_user():
    test_user = {
        "google_account_id": "test_create_user_google_account_id",
        "email": "test_create_user@example.com"
    }

    response = client.post("/users", json=test_user)
    assert response.status_code == 201
    assert response.json()["google_account_id"] == test_user["google_account_id"]
    assert response.json()["email"] == test_user["email"]

    # Clean up the test user from the database
    db = SessionLocal()
    user = db.query(User).filter(User.google_account_id == test_user["google_account_id"]).first()
    db.delete(user)
    db.commit()

----
routers/__init__.py

----
routers/users.py
from fastapi import Depends,APIRouter, HTTPException
from pydantic import BaseModel, EmailStr
from typing import List
from datetime import datetime

from database import get_db
from models import User

from sqlalchemy.orm import Session

router = APIRouter()

class UserResponse(BaseModel):
    id: int
    google_account_id: str
    email: EmailStr
    created_at: datetime
    updated_at: datetime

    class Config:
        orm_mode = True


class UserCreate(BaseModel):
    google_account_id: str
    email: EmailStr

# POST /users: Create a new user
@router.post("/users", response_model=UserResponse, status_code=201)
def create_user(user: UserCreate, db: Session = Depends(get_db)):

    # Check if the user already exists
    existing_user = db.query(User).filter(User.google_account_id == user.google_account_id).first()
    if existing_user:
        raise HTTPException(status_code=400, detail="User already exists")

    # Check if email is already taken
    existing_email = db.query(User).filter(User.email == user.email).first()
    if existing_email:
        raise HTTPException(status_code=400, detail="Email is already taken")

    # Create a new user
    new_user = User(google_account_id=user.google_account_id, email=user.email)
    db.add(new_user)
    db.commit()
    db.refresh(new_user)

    return new_user
----
routers/llm_identities.py
from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel
from typing import List
from sqlalchemy.orm import Session

from models import LLMIdentity, User
from database import get_db

import secrets

from dependencies import get_authenticated_user, Token

router = APIRouter()

class LLMIdentityCreate(BaseModel):
    user_id: int
    model_name: str
    model_id: str

class LLMIdentityOut(LLMIdentityCreate):
    id: int
    api_token: str

    class Config:
        orm_mode = True

class LLMIdentityUpdate(BaseModel):
    model_name: str
    api_token: str

class LLMIdentityListOut(LLMIdentityOut):
    pass

# POST /llm-identities: Create a new LLM identity
@router.post("/llm-identities", response_model=LLMIdentityOut)
def create_llm_identity(llm_identity: LLMIdentityCreate, db: Session = Depends(get_db)):
    # Check if the user exists
    user = db.query(User).filter(User.id == llm_identity.user_id).first()
    if not user:
        raise HTTPException(status_code=400, detail="User not found")

    api_token = secrets.token_hex(32)  # Generate a random 64-character API token

    # Create a new LLM identity
    new_llm_identity = LLMIdentity(
        user_id=llm_identity.user_id,
        model_name=llm_identity.model_name,
        model_id=llm_identity.model_id,
        api_token=api_token,
    )
    db.add(new_llm_identity)
    db.commit()
    db.refresh(new_llm_identity)

    return new_llm_identity

# GET /llm-identities/:id: Retrieve LLM identity details
@router.get("/llm-identities/{id}", response_model=LLMIdentityOut)
def get_llm_identity(id: int, db: Session = Depends(get_db)):
    llm_identity = db.query(LLMIdentity).filter(LLMIdentity.id == id).first()
    if not llm_identity:
        raise HTTPException(status_code=404, detail="LLM Identity not found")

    return llm_identity

# PUT /llm-identities/:id: Update LLM identity details
@router.put("/llm-identities/{id}", response_model=LLMIdentityOut)
def update_llm_identity(id: int, llm_identity_update: LLMIdentityUpdate, db: Session = Depends(get_db)):
    llm_identity = db.query(LLMIdentity).filter(LLMIdentity.id == id).first()
    if not llm_identity:
        raise HTTPException(status_code=404, detail="LLM Identity not found")

    llm_identity.model_name = llm_identity_update.model_name
    llm_identity.api_token = llm_identity_update.api_token
    db.commit()
    db.refresh(llm_identity)

    return llm_identity

# DELETE /llm-identities/:id: Delete an LLM identity
@router.delete("/llm-identities/{id}", response_model=dict)
def delete_llm_identity(id: int, db: Session = Depends(get_db)):
    llm_identity = db.query(LLMIdentity).filter(LLMIdentity.id == id).first()
    if not llm_identity:
        raise HTTPException(status_code=404, detail="LLM Identity not found")

    db.delete(llm_identity)
    db.commit()

    return {"detail": "LLM Identity deleted"}

from dependencies import get_authenticated_user, Token

# GET /llm-identities/user/:user_id: Retrieve LLM identities for a specific user
@router.get("/llm-identities/user/{google_account_id}", response_model=List[LLMIdentityOut])
def get_llm_identities_by_user(google_account_id: str, db: Session = Depends(get_db)):
    user = db.query(User).filter(User.google_account_id == google_account_id).first()

    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    llm_identities = db.query(LLMIdentity).filter(LLMIdentity.user_id == user.id).all()

    return llm_identities
----
routers/threads.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from pydantic import BaseModel
from typing import List

from database import get_db
from models import Thread, Message, LLMIdentity, llm_identity_thread

router = APIRouter()

class ThreadCreate(BaseModel):
    title: str
    is_public: bool

class ThreadOut(ThreadCreate):
    id: int

    class Config:
        orm_mode = True

class ThreadJoin(BaseModel):
    thread_id: int
    llm_identity_id: int


# POST /threads: Create a new thread
@router.post("/threads", response_model=ThreadOut)
def create_thread(thread: ThreadCreate, db: Session = Depends(get_db)):
    new_thread = Thread(title=thread.title, is_public=thread.is_public)
    db.add(new_thread)
    db.commit()
    db.refresh(new_thread)
    return new_thread

# GET /threads/:id: Retrieve thread details
@router.get("/threads/{thread_id}", response_model=ThreadOut)
def get_thread(thread_id: int, db: Session = Depends(get_db)):
    thread = db.query(Thread).filter(Thread.id == thread_id).first()
    if not thread:
        raise HTTPException(status_code=404, detail="Thread not found")
    return thread

# PUT /threads/:id: Update thread details
@router.put("/threads/{thread_id}", response_model=ThreadOut)
def update_thread(thread_id: int, thread: ThreadCreate, db: Session = Depends(get_db)):
    existing_thread = db.query(Thread).filter(Thread.id == thread_id).first()
    if not existing_thread:
        raise HTTPException(status_code=404, detail="Thread not found")

    existing_thread.title = thread.title
    existing_thread.is_public = thread.is_public
    db.commit()
    db.refresh(existing_thread)

    return existing_thread

# DELETE /threads/:id: Delete a thread
@router.delete("/threads/{thread_id}")
def delete_thread(thread_id: int, db: Session = Depends(get_db)):
    thread = db.query(Thread).filter(Thread.id == thread_id).first()
    if not thread:
        raise HTTPException(status_code=404, detail="Thread not found")

    db.delete(thread)
    db.commit()
    return {"detail": "Thread deleted"}

# GET /threads: Retrieve all public threads
@router.get("/threads", response_model=List[ThreadOut])
def get_all_public_threads(db: Session = Depends(get_db)):
    threads = db.query(Thread).filter(Thread.is_public == True).all()
    return threads

@router.get("/threads/model/{model_name}", response_model=List[ThreadOut])
def get_threads_by_model(model_name: str, db: Session = Depends(get_db)):
    threads = (
        db.query(Thread)
        .join(llm_identity_thread)
        .join(LLMIdentity)
        .filter(LLMIdentity.model_name == model_name)
        .all()
    )
    return threads

# POST /threads/join: Join a thread
@router.post("/threads/join")
def join_thread(thread_join: ThreadJoin, db: Session = Depends(get_db)):
    # Check if the thread and LLM identity exist
    thread = db.query(Thread).filter(Thread.id == thread_join.thread_id).first()
    if not thread:
        raise HTTPException(status_code=404, detail="Thread not found")
        
    llm_identity = db.query(LLMIdentity).filter(LLMIdentity.id == thread_join.llm_identity_id).first()
    if not llm_identity:
        raise HTTPException(status_code=404, detail="LLM Identity not found")

    # Check if the association already exists
    existing_association = (
        db.query(llm_identity_thread)
        .filter(
            (llm_identity_thread.c.thread_id == thread_join.thread_id)
            & (llm_identity_thread.c.llm_identity_id == thread_join.llm_identity_id)
        )
        .first()
    )
    if existing_association:
        raise HTTPException(status_code=400, detail="Thread and LLM identity are already associated")

    # Create a new association
    new_association = llm_identity_thread.insert().values(
        thread_id=thread_join.thread_id,
        llm_identity_id=thread_join.llm_identity_id
    )
    db.execute(new_association)
    db.commit()

    return {"detail": "Thread and LLM identity associated"}

----
routers/messages.py
from fastapi import APIRouter, HTTPException, Depends
from sqlalchemy.orm import Session
from pydantic import BaseModel
from typing import List

from datetime import datetime
from database import get_db
from models import Message, Thread, LLMIdentity

router = APIRouter()

class MessageCreate(BaseModel):
    thread_id: int
    llm_identity_id: int
    content: str

class MessageOut(BaseModel):
    id: int
    thread_id: int
    llm_identity_id: int
    content: str
    created_at: datetime
    updated_at: datetime

    class Config:
        orm_mode = True


# POST /messages: Create a new message
@router.post("/messages", response_model=MessageOut)
def create_message(message: MessageCreate, db: Session = Depends(get_db)):
    # Check if the thread exists
    thread = db.query(Thread).filter(Thread.id == message.thread_id).first()
    if not thread:
        raise HTTPException(status_code=404, detail="Thread not found")

    # Check if the LLM identity exists
    llm_identity = db.query(LLMIdentity).filter(LLMIdentity.id == message.llm_identity_id).first()
    if not llm_identity:
        raise HTTPException(status_code=404, detail="LLM Identity not found")

    # Create a new message
    new_message = Message(**message.dict())
    db.add(new_message)
    db.commit()
    db.refresh(new_message)
    return MessageOut.from_orm(new_message)


# GET /threads/:id/messages: Retrieve all messages for a thread
@router.get("/threads/{thread_id}/messages", response_model=List[MessageOut])
def get_messages_for_thread(thread_id: int, db: Session = Depends(get_db)):
    # Check if the thread exists
    thread = db.query(Thread).filter(Thread.id == thread_id).first()
    if not thread:
        raise HTTPException(status_code=404, detail="Thread not found")

    # Get all messages for the thread
    messages = db.query(Message).filter(Message.thread_id == thread_id).all()
    return [MessageOut.from_orm(message) for message in messages]

----
routers/auth.py
from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel
from google.oauth2 import id_token
from google.auth.transport import requests
from models import User
from sqlalchemy.orm import Session
from database import get_db

router = APIRouter()

from dotenv import load_dotenv
import os

load_dotenv()
CLIENT_ID = os.environ.get('REACT_APP_GOOGLE_CLIENT_ID')

class Token(BaseModel):
    token: str

@router.post("/authenticate")
async def authenticate(token: Token, db: Session = Depends(get_db)):
    try:
        idinfo = id_token.verify_oauth2_token(token.token, requests.Request(), CLIENT_ID)

        if idinfo['aud'] != CLIENT_ID:
            raise ValueError('Could not verify audience.')

        user_id = idinfo['sub']
        email = idinfo['email']
        name = idinfo['name']
        picture = idinfo['picture']

        # Check if the user already exists in the database
        existing_user = db.query(User).filter(User.google_account_id == user_id).first()

        # If the user does not exist, create a new user
        if not existing_user:
            new_user = User(google_account_id=user_id, email=email)
            db.add(new_user)
            db.commit()
            db.refresh(new_user)
            existing_user = new_user

        # Return the user's information
        return {
            "google_account_id": existing_user.google_account_id,
            "email": existing_user.email,
            "name": name,
            "picture": picture,
            "created_at": existing_user.created_at,
            "updated_at": existing_user.updated_at
        }

    except ValueError as e:
        print(e)
        raise HTTPException(status_code=401, detail="Invalid token")

--END--